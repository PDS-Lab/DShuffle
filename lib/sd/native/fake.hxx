#pragma once

#include <jni.h>

#include <cassert>
#include <cstring>

#include "sd/native/basic_type.hxx"
#include "sd/native/jvm_args.hxx"

namespace dpx::sd {

struct FakeSymbol {
  uint16_t length;
  int16_t refcount;
  uint32_t identity_hash;
  char raw[];  // name or signature

  std::string_view get_view() const { return std::string_view(raw, length); }
};

struct FakeConstantPool {
  void *vtable_pointer;
  char padding1[52];
  int length;
  char padding2[16];
  FakeSymbol *symbol_array[];  // [0] is unused
};

struct FakeFieldInfo {
  uint16_t access_flags;
  uint16_t name_index_offset;
  uint16_t signature_index_offset;
  uint16_t initval_index_offset;
  uint16_t low_packed_offset;
  uint16_t high_packed_offset;

  // clang-format off
#define JVM_ACC_PUBLIC        0x0001  /* visible to everyone */
#define JVM_ACC_PRIVATE       0x0002  /* visible only to the defining class */
#define JVM_ACC_PROTECTED     0x0004  /* visible to subclasses */
#define JVM_ACC_STATIC        0x0008  /* instance variable is static */
#define JVM_ACC_FINAL         0x0010  /* no further subclassing, overriding */
#define JVM_ACC_SYNCHRONIZED  0x0020  /* wrap method call in monitor lock */
#define JVM_ACC_SUPER         0x0020  /* funky handling of invokespecial */
#define JVM_ACC_VOLATILE      0x0040  /* can not cache in registers */
#define JVM_ACC_BRIDGE        0x0040  /* bridge method generated by compiler */
#define JVM_ACC_TRANSIENT     0x0080  /* not persistent */
#define JVM_ACC_VARARGS       0x0080  /* method declared with variable number of args */
#define JVM_ACC_NATIVE        0x0100  /* implemented in C */
#define JVM_ACC_INTERFACE     0x0200  /* class is an interface */
#define JVM_ACC_ABSTRACT      0x0400  /* no definition provided */
#define JVM_ACC_STRICT        0x0800  /* strict floating point */
#define JVM_ACC_SYNTHETIC     0x1000  /* compiler-generated class, method or field */
#define JVM_ACC_ANNOTATION    0x2000  /* annotation type */
#define JVM_ACC_ENUM          0x4000  /* field is declared as element of enum */

  bool is_public      () const         { return (access_flags & JVM_ACC_PUBLIC      ) != 0; }
  bool is_private     () const         { return (access_flags & JVM_ACC_PRIVATE     ) != 0; }
  bool is_protected   () const         { return (access_flags & JVM_ACC_PROTECTED   ) != 0; }
  bool is_static      () const         { return (access_flags & JVM_ACC_STATIC      ) != 0; }
  bool is_final       () const         { return (access_flags & JVM_ACC_FINAL       ) != 0; }
  bool is_synchronized() const         { return (access_flags & JVM_ACC_SYNCHRONIZED) != 0; }
  bool is_super       () const         { return (access_flags & JVM_ACC_SUPER       ) != 0; }
  bool is_volatile    () const         { return (access_flags & JVM_ACC_VOLATILE    ) != 0; }
  bool is_transient   () const         { return (access_flags & JVM_ACC_TRANSIENT   ) != 0; }
  bool is_native      () const         { return (access_flags & JVM_ACC_NATIVE      ) != 0; }
  bool is_interface   () const         { return (access_flags & JVM_ACC_INTERFACE   ) != 0; }
  bool is_abstract    () const         { return (access_flags & JVM_ACC_ABSTRACT    ) != 0; }
  bool is_strict      () const         { return (access_flags & JVM_ACC_STRICT      ) != 0; }

  enum {
    JVM_ACC_FIELD_INTERNAL              = 0x00000400, // internal field, same as JVM_ACC_ABSTRACT
    JVM_ACC_FIELD_HAS_GENERIC_SIGNATURE = 0x00000800, // field has generic signature
  };
  bool is_internal() const      { return (access_flags & JVM_ACC_FIELD_INTERNAL) != 0; }
  bool field_has_generic_signature() const
                                { return (access_flags & JVM_ACC_FIELD_HAS_GENERIC_SIGNATURE) != 0; }
  // clang-format on

  std::string_view signature_view(const FakeConstantPool *cp) const {
    return cp->symbol_array[signature_index_offset]->get_view();
  }

  std::string_view name_view(const FakeConstantPool *cp) const {
    return cp->symbol_array[name_index_offset]->get_view();
  }

  std::string signature(const FakeConstantPool *cp) const { return std::string(signature_view(cp)); }

  std::string name(const FakeConstantPool *cp) const { return std::string(name_view(cp)); }

  basic_type_t type(const FakeConstantPool *cp) const { return char2type(signature_view(cp)[0]); }

  uint32_t offset() const {
    assert((low_packed_offset & 3) == 1);
    return ((high_packed_offset << 16) | low_packed_offset) >> 2;
  }
};

struct FakeFieldInfoArray {
  uint32_t length;  // n of uint16_t
  FakeFieldInfo infos[];
};

struct LayoutHelper {
  int32_t lh;
  // MSB:[tag, hsz, ebt, log2(esz)]:LSB
  // where:
  //    tag is 0x80 if the elements are oops, 0xC0 if non-oops
  //    hsz is array header size in bytes (i.e., offset of first element)
  //    ebt is the BasicType of the elements
  //    esz is the element size in bytes
  bool is_instance() const { return lh > 0; }
  uint32_t object_size() const { return lh & 0xFFFFFFFE; }
  bool is_array() const { return lh < 0; }
  bool is_type_array() const { return (uint32_t)lh >= 0xC0000000; }
  // bool is_object_array() const { return lh < 0xC0000000; }
  int array_header_size() const { return (lh >> 16) & 0xFF; }
  basic_type_t element_type() const { return (basic_type_t)((lh >> 8) & 0xFF); }
  uint64_t element_size() const { return 1 << ((lh >> 0) & 0x3F); }
};

struct FakeObject;
struct FakeMetadata {
  virtual ~FakeMetadata() {}
};
struct FakeKlass : FakeMetadata {
  // void *vtable_pointer;
  // int32_t layout_helper;
  LayoutHelper lh;
  int32_t super_check_offset;
  FakeSymbol *symbol;
  char padding0[76];
  const FakeObject *mirror;
  FakeKlass *super;
  char padding1[74];
  int16_t shared_class_path_index;

  std::string_view signature() const { return symbol->get_view(); }
  bool is_enum() const { return super != nullptr && super->signature() == "java/lang/Enum"; }
  jclass clazz() const { return (jclass)&mirror; }

  static const FakeKlass *from_clazz(jclass j_class);
};

struct FakeInstanceKlass : public FakeKlass {
  char padding1[16];
  const FakeConstantPool *constant_pool;
  char padding2[24];
  int32_t nonstatic_field_size;
  int32_t static_field_size;
  int16_t generic_signature_index;
  int16_t source_file_name_index;
  int16_t static_oop_field_count;
  int16_t java_fields_count;
  int32_t nonstatic_oop_map_size;
  char padding3[160];
  const FakeFieldInfoArray *field_info_array;

  // embedded Java vtable follows here
  // embedded Java itables follows here
  // embedded static fields follows here
  // embedded nonstatic oop-map blocks follows here
  // embedded implementor of this interface follows here
  //   The embedded implementor only exists if the current klass is an
  //   iterface. The possible values of the implementor fall into following
  //   three cases:
  //     NULL: no implementor.
  //     A Klass* that's not itself: one implementor.
  //     Itself: more than one implementors.
  // embedded host klass follows here
  //   The embedded host klass only exists in an anonymous class for
  //   dynamic language support (JSR 292 enabled). The host class grants
  //   its access privileges to this class also. The host class is either
  //   named, or a previously loaded anonymous class. A non-anonymous class
  //   or an anonymous class loaded through normal classloading does not
  //   have this embedded field.
  //

  std::pair<uint8_t, uint8_t> fields_count() const {
    assert(lh.is_instance());
    auto limit = field_info_array->length;
    auto static_count = 0;
    for (uint32_t i = 0; i * 6 < limit; i++) {
      const auto &info = field_info_array->infos[i];
      if (info.field_has_generic_signature()) {
        limit--;
      }
      if (info.is_static()) {
        static_count++;
      }
    }
    return {limit / 6, static_count};
  }

  const FakeFieldInfo &field(uint32_t index) const {
    assert(lh.is_instance());
    return field_info_array->infos[index];
  }
};

struct FakeArrayKlass : public FakeKlass {
  uint32_t dimension;
  FakeArrayKlass *higher_dimension;
  FakeArrayKlass *lower_dimension;
  int vtable_len;
  void *oop;
};

struct FakeObjectArrayKlass : public FakeArrayKlass {
  FakeInstanceKlass *element_klass;
  FakeKlass *bottom_klass;
};

struct FakeTypeArrayKlass : public FakeArrayKlass {
  int max_length;
};

struct FakeObject {
  uint64_t mark;
  char content[];

  char *raw(uint32_t offset) { return &content[offset - sizeof(FakeObject)]; }
  const char *raw(uint32_t offset) const { return const_cast<FakeObject *>(this)->raw(offset); }

  template <typename T>
  T parse_at(uint32_t offset) const {
    return *(T *)raw(offset);
  }

  template <typename T>
  void place_at(uint32_t offset, T value) {
    *(T *)raw(offset) = value;
  }

  FakeObject *reference_at(uint32_t offset) {
    return (FakeObject *)JVMArgs::parse_heap_cptr(parse_at<uint32_t>(offset));
  }
  const FakeObject *reference_at(uint32_t offset) const { return const_cast<FakeObject *>(this)->reference_at(offset); }

  // klass pointer must be placed after the mark
  FakeKlass *klass_pointer() {
    return (FakeKlass *)JVMArgs::parse_metaspace_cptr(parse_at<uint32_t>(sizeof(FakeObject)));
  }
  const FakeKlass *klass_pointer() const { return const_cast<FakeObject *>(this)->klass_pointer(); }

  uint32_t enum_ordinal() const { return parse_at<uint32_t>(sizeof(FakeObject) + sizeof(uint32_t)); }

  // NOTICE: fetch from metaspace
  uint32_t array_header_size() const { return klass_pointer()->lh.array_header_size(); }
  // array length will be placed in the last 4 bytes of array header
  uint32_t array_length(uint32_t base) const { return parse_at<uint32_t>(base - sizeof(uint32_t)); }

  template <typename T>
  T array_elem_at(uint32_t base, uint32_t i) const {
    return parse_at<T>(base + i * sizeof(T));
  }

  const FakeObject *array_elem_ref(uint32_t base, uint32_t i) const {
    return reference_at(base + i * sizeof(uint32_t));
  }

  // creators
 public:
  static FakeObject *from_cptr(uint64_t cptr) { return (FakeObject *)JVMArgs::parse_heap_cptr(cptr); }
  static FakeObject *from_jobject(jobject j_object) { return (FakeObject *)(*(void **)j_object); }
  static FakeObject *from_jarray(jarray j_array) { return (FakeObject *)(*(void **)j_array); }
  // jclass is java/lang/class, a special object
  static FakeObject *from_clazz(jclass j_class) { return from_jobject(j_class); }
};

inline const FakeKlass *FakeKlass::from_clazz(jclass j_class) {
  // this is an object, java/lang/Class
  auto class_object = FakeObject::from_clazz(j_class);
  // get its klass
  auto class_klass = (const FakeInstanceKlass *)class_object->klass_pointer();
  // get the klass pointer of the target class
  // after the normal fields, there are 7 injected fields
  // clang-format off
// #define CLASS_INJECTED_FIELDS(macro)                                       \
//   macro(java_lang_Class, klass,                  intptr_signature,  false) \
//   macro(java_lang_Class, array_klass,            intptr_signature,  false) \
//   macro(java_lang_Class, oop_size,               int_signature,     false) \
//   macro(java_lang_Class, static_oop_field_count, int_signature,     false) \
//   macro(java_lang_Class, protection_domain,      object_signature,  false) \
//   macro(java_lang_Class, init_lock,              object_signature,  false) \
//   macro(java_lang_Class, signers,                object_signature,  false)
  // clang-format on
  auto injected_fields_idx_base = class_klass->java_fields_count;
  auto target_klass_pointer_offset = class_klass->field(injected_fields_idx_base).offset();
  auto target_klass = class_object->parse_at<uintptr_t>(target_klass_pointer_offset);
  return (const FakeKlass *)target_klass;
}

}  // namespace dpx::sd
